/* Program to read raw socket packets using the pcap library and write them to 
 * file.
 * Compile: gcc -o rawpcap rawpcap.c -Wall -lpcap
 * pep/10apr08
 * Modified by Jayanth Chennamangalam on 2008.04.23
 */

#include <stdio.h>
#include <errno.h>
#include <pcap.h>
#include <sys/types.h>
#include <net/ethernet.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <stdlib.h>
#include <string.h>

enum {MaxPktSize=65536, PROMISC=1, TimeOut=1000};
FILE *Fpkt = NULL;

void proc_pkt (u_char *args, const struct pcap_pkthdr *hdr, const u_char *pkt)
{ struct ether_header *ethhead;
  struct iphdr *iphead;
  struct udphdr *udphead;
  char *pktdata;
  static int pktcnt = 0;

  if (pkt == NULL)
  {
      printf("pkt is NULL\n");
      return; 
  }
  ethhead = (struct ether_header*) (pkt);
  iphead  = (struct iphdr*) (pkt + sizeof (struct ether_header));
  udphead = (struct udphdr*) ((char*)(iphead) + sizeof (struct iphdr));
  pktdata = (char*) ((char*)(udphead) + sizeof (struct udphdr));

  if (pktcnt++ %10 == 9) fprintf (stderr, ".");
  fwrite (pktdata, 1024, 1, Fpkt);
  //fwrite (pktdata, udphead->len, 1, Fpkt);
}

int main (int argc, char *argv[])
{ char *dev, errbuf [PCAP_ERRBUF_SIZE], mydev[] = "eth1";
  pcap_t *handle = NULL;
  
  // dev = pcap_lookupdev (errbuf);
  if (argc == 2) strcpy (mydev, argv[1]);
  fprintf (stderr," %s: Using device %s\n", argv[0], mydev);
  if ((Fpkt = fopen ("pcap.dat", "wb")) == NULL)
  { perror ("fopen"); return -1; }

  if ((handle = pcap_open_live (mydev, MaxPktSize, PROMISC, TimeOut, errbuf)) 
       == NULL) 
  { fprintf (stderr, "%s\n", errbuf); return -1; }

  
  pcap_loop (handle, -1, proc_pkt, 0);

  if (handle) pcap_close (handle);
  if (Fpkt) fclose (Fpkt);
  return 0;
}

